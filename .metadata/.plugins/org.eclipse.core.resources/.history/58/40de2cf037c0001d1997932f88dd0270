package com.project;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.LinkedHashMap;
import java.util.Map;
import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.FileReader;
import java.io.FileWriter;
import javax.xml.parsers.DocumentBuilder;
import javax.xml.parsers.DocumentBuilderFactory;
import org.w3c.dom.Document;
import org.w3c.dom.Element;
import org.w3c.dom.Node;
import org.w3c.dom.NodeList;

public class App {
    public ArrayList<Measure> extractInformation2() {
        ArrayList<Measure> measureArrayList = new ArrayList<Measure>();
        DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();

        try {
            // Check if original file exists
            DocumentBuilder builder = factory.newDocumentBuilder();
            String path = "Golden Slippers - transposed from D into C.musicxml";
            File f = new File(path);
            if (!f.exists()) {
                System.out.println("File does not exists");
                return null;
            }

            // If original file exists, copy it to tempMusic.xml file.
            File file = new File("tempMusic.xml");
            boolean result = file.createNewFile();
            // Copy contents of original file to tempMusic.xml file.
            copyContent(f, file);

            // Remove first two lines of tempMusic.xml file
            BufferedReader reader = new BufferedReader(new FileReader(file));
            BufferedWriter writer = new BufferedWriter(new FileWriter(file + "tmp.xml"));
            reader.readLine();
            reader.readLine();
            String line;
            while ((line = reader.readLine()) != null) {
                writer.write(line + "\n");
            }
            reader.close();
            writer.close();
            File originalFile = file;
            File tempFile = new File(file + "tmp.xml");
            originalFile.delete();
            tempFile.renameTo(originalFile);
            System.out.println("The first two lines have been deleted from the file.");
            System.out.println("------------------------------------------------------------------");

            Document document = builder.parse(file);

            // Normalize the xml structure
            document.getDocumentElement().normalize();

            // Get all elements by tag name
            NodeList measureList = document.getElementsByTagName("measure");
            
            // Iterating through each measure
            for (int i = 0; i < measureList.getLength(); i++) 
            {
                Measure measureObj = new Measure();
                Node measure = measureList.item(i);
                if (measure.getNodeType() == Node.ELEMENT_NODE) 
                {
                    // Getting children of measure
                    NodeList measureChildList = measure.getChildNodes();
                    // Harmony and notelist object creation
                    String rootStep = "C";
                    String kind = "";
                    ArrayList<Note> noteArrayList = new ArrayList<>();
                    Harmony harmony = new Harmony();
                    String step = "";
                    String duration = "";
                    String type = "";
                    String beam = "";

                    for (int j = 0; j < measureChildList.getLength(); j++)
                    {
                        Node measureChild = measureChildList.item(j);
                        Note noteObj = new Note();
                        if (measureChild.getNodeType() == Node.ELEMENT_NODE) 
                        {
                            Element measureChildElement = (Element) measureChild;
                            if (measureChildElement.getNodeName().equals("harmony")) 
                            {
                                // Getting list of harmonys
                                NodeList harmonyList = measureChildElement.getChildNodes();
                                for (int k = 0; k < harmonyList.getLength(); k++) // [root, kind, staff]
                                {
                                    // Get specific harmony from the harmony list
                                    Node harmonyChild = harmonyList.item(k);
                                    if (harmonyChild.getNodeType() == Node.ELEMENT_NODE) 
                                    {
                                        Element harmonyChildElement = (Element) harmonyChild;
                                        if (harmonyChildElement.getNodeName().equals("root")) 
                                        {
                                            // Get list of all roots
                                            NodeList rootList = harmonyChildElement.getChildNodes();
                                            for (int l = 0; l < rootList.getLength(); l++) // [step, octave]
                                            {
                                                // get specific root from the root list
                                                Node rootChild = rootList.item(l);
                                                if (rootChild.getNodeType() == Node.ELEMENT_NODE) 
                                                {
                                                    Element rootChildElement = (Element) rootChild;
                                                    if (rootChildElement.getNodeName().equals("root-step")) 
                                                    {
                                                        rootStep = rootChildElement.getTextContent();
                                                    }
                                                }
                                            }
                                        }
                                        if (harmonyChildElement.getNodeName().equals("kind")) 
                                        {
                                            kind = harmonyChildElement.getTextContent();
                                        }
                                    }
                                }
                                //harmony.setRootStep(rootStep);
                                //harmony.setKind(kind);
                            } 
                            else if (measureChildElement.getNodeName().equals("note")) 
                            {
                                NodeList noteList = measureChildElement.getChildNodes();
                                for (int k = 0; k < noteList.getLength(); k++) // [pitch, duration, instrument,voice,type, stem, staff]
                                {
                                    // Getting a specific note
                                    Node noteChild = noteList.item(k);
                                    if (noteChild.getNodeType() == Node.ELEMENT_NODE) {
                                        Element noteChildElement = (Element) noteChild;
                                        if (noteChildElement.getNodeName().equals("rest")) {
                                            step = "c";
                                        }
                                        if (noteChildElement.getNodeName().equals("pitch")) {
                                            // Getting a list of pitch
                                            NodeList pitchList = noteChildElement.getChildNodes();
                                            for (int l = 0; l < pitchList.getLength(); l++) // [step, octave]
                                            {
                                                // getting a specific pitch
                                                Node pitch = pitchList.item(l);
                                                if (pitch.getNodeType() == Node.ELEMENT_NODE) {
                                                    Element pitchChildElement = (Element) pitch;
                                                    if (pitchChildElement.getNodeName().equals("step")) {
                                                        step = pitchChildElement.getTextContent();
                                                    }
                                                }
                                            }
                                        }
                                        if (noteChildElement.getNodeName().equals("type")) {
                                            type = noteChildElement.getTextContent();
                                        }
                                        if (noteChildElement.getNodeName().equals("beam")) {
                                            beam = noteChildElement.getTextContent();
                                        }
                                    }
                                }
                                noteObj.setStep(step);
                                noteObj.setDuration(duration);
                                noteObj.setType(type);
                                noteObj.setBeam(beam);
                                noteArrayList.add(noteObj);
                            }
                        }
                        harmony.setRootStep(rootStep);
                        harmony.setKind(kind);
                        measureObj.setHarmony(harmony);
                        measureObj.setNoteList(noteArrayList);
                    }
                }
                measureArrayList.add(measureObj);
            }
        } catch (Exception e) {
            e.printStackTrace();
        }
        return measureArrayList;
    }
    public static void copyContent(File a, File b) throws Exception {
        FileInputStream in = new FileInputStream(a);
        FileOutputStream out = new FileOutputStream(b);
        try {
            int n;
            while ((n = in.read()) != -1) {
                out.write(n);
            }
        } finally {
            if (in != null) {
                in.close();
            }
            if (out != null) {
                out.close();
            }
        }
        System.out.println("File Copied");
    }

    public static void main(String[] args) {
        App app = new App();
        
        // 1. Extract information from musicxml
        ArrayList<Measure> measureList = app.extractInformation2();

        /*for (int s = 0; s < measureList.size(); s++) {
            System.out.println("Measure ->");

            System.out.println("Harmony : ");

            System.out.println("rootstep : " + measureList.get(s).getHarmony().getRootStep());
            System.out.println("kind : " + measureList.get(s).getHarmony().getKind());

            System.out.println(s+1);
            for (int t = 0; t < measureList.get(s).getNoteList().size(); t++) {
                System.out.println("Step : " + measureList.get(s).getNoteList().get(t).getStep());
                System.out.println("Duration : " + measureList.get(s).getNoteList().get(t).getDuration());
                System.out.println("Type : " + measureList.get(s).getNoteList().get(t).getType());
                System.out.println("Beam : " + measureList.get(s).getNoteList().get(t).getBeam());
                System.out.println();
            }
            System.out.println();
        }*/
        
        
        // 2. Get lists and rootsteps in the format of 5
        ArrayList<UpdatedMeasure> updatedMeasureArrayList = app.calculateUpdatedMeasureList(measureList);
        ArrayList<String> step  = new ArrayList<String>();
        ArrayList<String> rootStep  = new ArrayList<String>();
        for(int x=0;x<updatedMeasureArrayList.size();x++) {
			//System.out.println("-------------Measure " + (int)(x+1) + "------------");
			UpdatedMeasure updatedMeasure = updatedMeasureArrayList.get(x);
			UpdatedHarmony updatedHarmony = updatedMeasure.getHarmony();
			//System.out.println("Rootstep: " + updatedHarmony.getRootStep());
			//System.out.println();
			ArrayList<UpdatedNote> updatedNoteList = updatedMeasure.getNoteList();
			for(int y=0; y<updatedNoteList.size(); y++) {
				UpdatedNote updatedNote = updatedNoteList.get(y);
				//System.out.println("Step: " + updatedNote.getStep());
				//System.out.println("Duration: " + updatedNote.getDuration());
				//System.out.println("Type: " + updatedNote.getType());
				//System.out.println("Beam: " + updatedNote.getBeam());
				step.add(updatedNote.getStep());
				rootStep.add(updatedHarmony.getRootStep());
			}
			//System.out.println();
		}
        
        ArrayList<String> noteRootstepString = new ArrayList<String>();
        System.out.println("  Note          Rootstep");
        System.out.println("----------------------------");
        for(int x=0; x<step.size()-5; x++) {
        	StringBuffer temp = new StringBuffer("");
    		for(int y=x; y<x+5; y++) {
    			System.out.print(step.get(y).toLowerCase() + " ");
    			temp.append(step.get(y).toLowerCase() + " ");
    		}
    		System.out.print("  -  ");
    		temp.append("  -  ");
    		for(int y=x; y<x+5; y++) {
    			System.out.print(rootStep.get(y).toUpperCase() + " ");
    			temp.append(rootStep.get(y).toUpperCase() + " ");
    		}
    		System.out.println();
    		String temp2 = new String(temp);
    		noteRootstepString.add(temp2);
        }
        System.out.println();
        
        
        // 3. Mapping of frequency of n-gram NOTES and m-gram CHORDS
        HashMap<String,Integer> hm = new HashMap<String,Integer>();
        for(String str: noteRootstepString) {
        	if(hm.containsKey(str)) {
        		hm.put(str, hm.get(str) + 1);
        	}
        	else {
        		hm.put(str, 1);
        	}
        }
        for(Map.Entry<String, Integer> set : hm.entrySet()) {
        	System.out.println(set.getKey() + " - " + set.getValue());
        }
        
    }

	public ArrayList<UpdatedMeasure> calculateUpdatedMeasureList(ArrayList<Measure> measureList) {
		ArrayList<UpdatedMeasure> updatedMeasureArrayList = new ArrayList<UpdatedMeasure>();
		
		for(int i=0; i<measureList.size(); i++) {
			Measure measure = measureList.get(i);
			UpdatedMeasure updatedMeasure = new UpdatedMeasure();
			
			UpdatedHarmony updatedHarmony = new UpdatedHarmony();
			//Harmony
			Harmony harmony = measure.getHarmony();
			
			String rootStep = harmony.getRootStep();
			String kind = harmony.getKind();
			String harmonyStr = rootStep;
			if(kind.equals("minor"))
				harmonyStr = harmonyStr.concat("m");
			else if(kind.equals("dominant"))
				harmonyStr = harmonyStr.concat("7");
			updatedHarmony.setRootStep(harmonyStr);
			
			ArrayList<UpdatedNote> updatedNoteList = new ArrayList<UpdatedNote>();
			ArrayList<UpdatedNote> tempupdatedMiddleNoteList = new ArrayList<UpdatedNote>();
			//ArrayList<Note>
			ArrayList<Note> noteList = measure.getNoteList();
			
			//If notelist size is 4 then add all nodes to updatedNoteList with type as quarter
			if(noteList.size() == 4) {
				for(int j=0; j<4; j++) {
					Note note = noteList.get(j);
					UpdatedNote updatedNote = new UpdatedNote();
					updatedNote.setStep(note.getStep());
					updatedNote.setDuration(note.getDuration());
					updatedNote.setType("quarter");
					updatedNote.setBeam(note.getBeam());
					updatedNoteList.add(updatedNote);
				}
			}
			else
			{
				//float count = 0;
				float notecount = 0;
				int middlecount = 0;
				for(int j=0; j<noteList.size() && notecount < 4; j++) 
				{
					Note note = noteList.get(j);
					if(note.getType().equals("full")) {
						UpdatedNote updatedNote = new UpdatedNote();
						updatedNote.setStep(note.getStep());
						updatedNote.setDuration(note.getDuration());
						updatedNote.setType("quarter");
						updatedNote.setBeam(note.getBeam());
						updatedNoteList.add(updatedNote);
						
						updatedNote = new UpdatedNote();
						updatedNote.setStep(note.getStep());
						updatedNote.setDuration(note.getDuration());
						updatedNote.setType("quarter");
						updatedNote.setBeam(note.getBeam());
						updatedNoteList.add(updatedNote);
						
						updatedNote = new UpdatedNote();
						updatedNote.setStep(note.getStep());
						updatedNote.setDuration(note.getDuration());
						updatedNote.setType("quarter");
						updatedNote.setBeam(note.getBeam());
						updatedNoteList.add(updatedNote);
						
						updatedNote = new UpdatedNote();
						updatedNote.setStep(note.getStep());
						updatedNote.setDuration(note.getDuration());
						updatedNote.setType("quarter");
						updatedNote.setBeam(note.getBeam());
						updatedNoteList.add(updatedNote);
						
						//System.out.println("full------------>" + note.getStep());
						//System.out.println("full------------>" + note.getStep());
						//System.out.println("full------------>" + note.getStep());
						//System.out.println("full------------>" + note.getStep());
						
						notecount = 4;
						break;
					}
					else if(note.getType().equals("half")) {
						UpdatedNote updatedNote = new UpdatedNote();
						updatedNote.setStep(note.getStep());
						updatedNote.setDuration(note.getDuration());
						updatedNote.setType("quarter");
						updatedNote.setBeam(note.getBeam());
						updatedNoteList.add(updatedNote);
						
						updatedNote = new UpdatedNote();
						updatedNote.setStep(note.getStep());
						updatedNote.setDuration(note.getDuration());
						updatedNote.setType("quarter");
						updatedNote.setBeam(note.getBeam());
						updatedNoteList.add(updatedNote);
						//System.out.println("half------------>" + note.getStep());
						//System.out.println("half------------>" + note.getStep());
						notecount = notecount + 2;
					}
					else if(note.getType().equals("quarter")) {
						UpdatedNote updatedNote = new UpdatedNote();
						updatedNote.setStep(note.getStep());
						updatedNote.setDuration(note.getDuration());
						updatedNote.setType("quarter");
						updatedNote.setBeam(note.getBeam());
						updatedNoteList.add(updatedNote);
						//System.out.println("quarter------------>" + note.getStep());
						notecount = notecount + 1;
					}
					else {
						boolean isEighthAtBeginning = true;
						if(note.getType().equals("eighth")) {                      //If eighth is the first case then add and skip others till it becomes node
							if(j == 0 && !note.getBeam().equals("begin")) {
								isEighthAtBeginning = false;
								UpdatedNote updatedNote = new UpdatedNote();
								updatedNote.setStep(note.getStep());
								updatedNote.setDuration(note.getDuration());
								updatedNote.setType("quarter");
								updatedNote.setBeam(note.getBeam());
								updatedNoteList.add(updatedNote);
								j++;
								notecount++;
							}
							else if(j == (noteList.size() - 1)) {                   //If eighth is the last case then add
								
								if(note.getBeam().equals("end") && middlecount == 3) {
									updatedNoteList.add(tempupdatedMiddleNoteList.get(tempupdatedMiddleNoteList.size()-2));
								}
								UpdatedNote updatedNote = new UpdatedNote();
								updatedNote.setStep(note.getStep());
								updatedNote.setDuration(note.getDuration());
								updatedNote.setType("quarter");
								updatedNote.setBeam(note.getBeam());
								updatedNoteList.add(updatedNote);
								notecount = 0;
								break;
							}
							else {                                                      //Check how many are the middle and then decide which one to take
								
								if(note.getBeam().equals("begin")) {
									middlecount=1;
									UpdatedNote updatedNote = new UpdatedNote();
									updatedNote.setStep(note.getStep());
									updatedNote.setDuration(note.getDuration());
									updatedNote.setType("quarter");
									updatedNote.setBeam(note.getBeam());
									tempupdatedMiddleNoteList.add(updatedNote);
								}
								else if(note.getBeam().equals("continue")) {
									middlecount++;
									UpdatedNote updatedNote = new UpdatedNote();
									updatedNote.setStep(note.getStep());
									updatedNote.setDuration(note.getDuration());
									updatedNote.setType("quarter");
									updatedNote.setBeam(note.getBeam());
									tempupdatedMiddleNoteList.add(updatedNote);
								}
								else if(note.getBeam().equals("end")) {
									middlecount++;
									UpdatedNote updatedNote = new UpdatedNote();
									updatedNote.setStep(note.getStep());
									updatedNote.setDuration(note.getDuration());
									updatedNote.setType("quarter");
									updatedNote.setBeam(note.getBeam());
									tempupdatedMiddleNoteList.add(updatedNote);
									
									if(isEighthAtBeginning == true)
									{
										if(middlecount == 2) {                                     //If middle elements are 3 then take the middle one i.e. 1st index
											updatedNoteList.add(tempupdatedMiddleNoteList.get(0));
											tempupdatedMiddleNoteList.clear();
											middlecount = 0;
										}
										else if(middlecount == 4) {                                //If middle elements are 4 then take the first one i.e. 0th index
											updatedNoteList.add(tempupdatedMiddleNoteList.get(0));
											updatedNoteList.add(tempupdatedMiddleNoteList.get(2));
											tempupdatedMiddleNoteList.clear();
											middlecount = 0;
										}
									}
									else {
										if(middlecount == 2 && notecount == 1.5) {                 //If middle elements are 3 then take the middle one i.e. 1st index
											updatedNoteList.add(tempupdatedMiddleNoteList.get(0));
											tempupdatedMiddleNoteList.clear();
											middlecount = 0;
										}
										else if(middlecount == 4 && notecount == 2.5) {            //If middle elements are 4 then take the first one i.e. 0th index
											updatedNoteList.add(tempupdatedMiddleNoteList.get(0));
											updatedNoteList.add(tempupdatedMiddleNoteList.get(3));
											tempupdatedMiddleNoteList.clear();
											middlecount = 0;
										}
									}
								}	
							}
							notecount += 0.5;
						}
						if(note.getType().equals("16th")) {                             //If 16th is the first case then add and skip others till it becomes node
							if(j == 0) {
								UpdatedNote updatedNote = new UpdatedNote();
								updatedNote.setStep(note.getStep());
								updatedNote.setDuration(note.getDuration());
								updatedNote.setType("quarter");
								updatedNote.setBeam(note.getBeam());
								updatedNoteList.add(updatedNote);
								j = j + 3;
								notecount++;
							}
							else if(j == (noteList.size() - 1)) {                        //If 16th is the last case then add
								UpdatedNote updatedNote = new UpdatedNote();
								updatedNote.setStep(note.getStep());
								updatedNote.setDuration(note.getDuration());
								updatedNote.setType("quarter");
								updatedNote.setBeam(note.getBeam());
								updatedNoteList.add(updatedNote);
								notecount = 0;
								break;
							}
							else {                                                        //Check how many are the middle and then decide which one to take
								if(note.getBeam().equals("begin")) {
									middlecount=0;
									UpdatedNote updatedNote = new UpdatedNote();
									updatedNote.setStep(note.getStep());
									updatedNote.setDuration(note.getDuration());
									updatedNote.setType("quarter");
									updatedNote.setBeam(note.getBeam());
									tempupdatedMiddleNoteList.add(updatedNote);
								}
								else if(note.getBeam().equals("continue")) {
									middlecount++;
									UpdatedNote updatedNote = new UpdatedNote();
									updatedNote.setStep(note.getStep());
									updatedNote.setDuration(note.getDuration());
									updatedNote.setType("quarter");
									updatedNote.setBeam(note.getBeam());
									tempupdatedMiddleNoteList.add(updatedNote);
								}
								else if(note.getBeam().equals("end")) {
									middlecount++;
									UpdatedNote updatedNote = new UpdatedNote();
									updatedNote.setStep(note.getStep());
									updatedNote.setDuration(note.getDuration());
									updatedNote.setType("quarter");
									updatedNote.setBeam(note.getBeam());
									tempupdatedMiddleNoteList.add(updatedNote);
									if(middlecount == 3) {                                     //If middle elements are 3 then take the middle one i.e. 1st index
										updatedNoteList.add(tempupdatedMiddleNoteList.get(1));
										tempupdatedMiddleNoteList.clear();
										middlecount = 0;
									}
									else if(middlecount == 4) {                                //If middle elements are 4 then take the first one i.e. 0th index
										updatedNoteList.add(tempupdatedMiddleNoteList.get(0));
										tempupdatedMiddleNoteList.clear();
										middlecount = 0;
									}
								}	
							}
							notecount += 0.25;
						}
					}
				}
			}
			updatedMeasure.setHarmony(updatedHarmony);
			updatedMeasure.setNoteList(updatedNoteList);
			updatedMeasureArrayList.add(updatedMeasure);
		}
		
		/*
		for(int x=0;x<updatedMeasureArrayList.size();x++) {
			UpdatedMeasure updatedMeasure = updatedMeasureArrayList.get(x);
			UpdatedHarmony updatedHarmony = updatedMeasure.getHarmony();
			System.out.println("Rootstep: " + updatedHarmony.getRootStep());
			System.out.println();
			ArrayList<UpdatedNote> updatedNoteList = updatedMeasure.getNoteList();
			for(int y=0; y<updatedNoteList.size(); y++) {
				UpdatedNote updatedNote = updatedNoteList.get(y);
				System.out.println("Step: " + updatedNote.getStep());
				System.out.println("Duration: " + updatedNote.getDuration());
				System.out.println("Type: " + updatedNote.getType());
				System.out.println("Beam: " + updatedNote.getBeam());
			}
			System.out.println("-------------Measure " + (int)(x+1) + " Ended------------");
			System.out.println();
			System.out.println();
			
		}*/
		return updatedMeasureArrayList;
	}
}
